<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Priyanshu ‚ù§Ô∏è Ria ‚Äî Drawing Canvas</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet">
<style>
:root{
  --gold:#D4AF37; --dark:#050814; --bg:#0A0E27; --text:#F5F5F5; --muted:#B0B0B0;
}
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%;background:linear-gradient(135deg,var(--dark),var(--bg));color:var(--text);font-family:'Poppins',sans-serif}
body{display:flex;flex-direction:column;min-height:100vh}
.header{padding:16px;text-align:center;background:linear-gradient(to bottom, rgba(212,175,55,0.04),transparent);border-bottom:1px solid rgba(212,175,55,0.08)}
.header h1{font-family:'Playfair Display',serif;background:linear-gradient(135deg,var(--gold),#C9A961);-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-size:24px}
.header p{font-size:12px;color:var(--muted);margin-top:4px}
.container{display:flex;gap:16px;padding:14px;flex:1;align-items:stretch}
.canvas-wrap{flex:1;min-height:320px;border-radius:12px;background:rgba(255,255,255,0.96);box-shadow:0 12px 40px rgba(0,0,0,0.35);overflow:hidden;border:1px solid rgba(212,175,55,0.12);position:relative}
#drawingCanvas{width:100%;height:100%;display:block;touch-action:none;cursor:crosshair;background:transparent}
.toolbar{width:340px;display:flex;flex-direction:column;gap:12px;max-height:calc(100vh - 120px);overflow:auto}
.panel{background:rgba(10,14,32,0.85);padding:12px;border-radius:10px;border:1px solid rgba(212,175,55,0.08);box-shadow:0 10px 30px rgba(0,0,0,0.25)}
.panel-title{color:var(--gold);font-weight:600;font-size:13px;margin-bottom:8px;display:flex;align-items:center;gap:8px}
.brush-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
.btn{padding:8px;border-radius:8px;border:1px solid rgba(212,175,55,0.08);background:rgba(212,175,55,0.04);color:var(--text);cursor:pointer;font-size:13px}
.btn.active{background:var(--gold);color:var(--dark);box-shadow:0 0 12px rgba(212,175,55,0.22)}
.range{width:100%}
.color-display{height:58px;border-radius:8px;border:2px solid rgba(212,175,55,0.08);box-shadow:inset 0 2px 8px rgba(0,0,0,0.15)}
.color-row{display:grid;grid-template-columns:1fr 90px;gap:8px;margin-top:8px}
.hex-input{padding:8px;border-radius:6px;background:rgba(212,175,55,0.03);border:1px solid rgba(212,175,55,0.06);color:var(--text);font-family:monospace}
.palette{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:10px}
.palette .sw{width:100%;aspect-ratio:1;border-radius:6px;border:2px solid rgba(212,175,55,0.06);cursor:pointer}
.tools{display:flex;flex-direction:column;gap:8px}
.small-row{display:flex;gap:8px}
.layers-list{display:flex;flex-direction:column;gap:8px;max-height:220px;overflow:auto;margin-top:8px}
.layer-item{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:8px;background:rgba(212,175,55,0.03);border:1px solid rgba(212,175,55,0.04);cursor:pointer}
.layer-item.active{box-shadow:0 0 10px rgba(212,175,55,0.12);border-color:var(--gold);background:linear-gradient(90deg, rgba(212,175,55,0.06), rgba(212,175,55,0.02))}
.layer-controls{display:flex;gap:6px;align-items:center}
.footer{padding:12px;text-align:center;background:linear-gradient(to top, rgba(212,175,55,0.04),transparent);border-top:1px solid rgba(212,175,55,0.06);color:var(--muted);font-size:13px}
.toast{position:fixed;right:20px;bottom:20px;background:var(--gold);color:var(--dark);padding:10px 14px;border-radius:8px;box-shadow:0 8px 30px rgba(0,0,0,0.3)}
.sparkle{position:absolute;pointer-events:none;border-radius:50%;width:6px;height:6px;animation:spark 0.6s ease-out forwards}
@keyframes spark{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0)}}
@media (max-width:1024px){.container{flex-direction:column}.toolbar{width:100%;max-height:260px;flex-direction:row;overflow:auto}.panel{min-width:260px;flex-shrink:0}}
</style>
</head>
<body>
  <div class="header">
    <h1>‚ú® Drawing Canvas</h1>
    <p>Created with love by Priyanshu for Ria ‚Äî upgraded & touch-fixed</p>
  </div>

  <div class="container">
    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="drawingCanvas" aria-label="drawing canvas"></canvas>
      <!-- optional overlay UI markers could go here -->
    </div>

    <div class="toolbar" id="toolbar">
      <div class="panel">
        <div class="panel-title">üé® Brush</div>
        <div class="brush-grid">
          <button class="btn brush-btn active" data-brush="pencil">Pencil</button>
          <button class="btn brush-btn" data-brush="charcoal">Charcoal</button>
          <button class="btn brush-btn" data-brush="marker">Marker</button>
          <button class="btn brush-btn" data-brush="oil">Oil</button>
          <button class="btn brush-btn" data-brush="watercolor">Watercolor</button>
          <button class="btn brush-btn" data-brush="airbrush">Airbrush</button>
        </div>

        <div style="margin-top:10px">
          <div style="display:flex;justify-content:space-between;font-size:13px;color:var(--muted)"><span>Size</span><span id="sizeVal">10</span></div>
          <input class="range" id="sizeRange" type="range" min="1" max="200" value="10">
        </div>
        <div style="margin-top:8px">
          <div style="display:flex;justify-content:space-between;font-size:13px;color:var(--muted)"><span>Opacity</span><span id="opVal">100%</span></div>
          <input class="range" id="opacityRange" type="range" min="0" max="100" value="100">
        </div>
        <div style="margin-top:8px">
          <div style="display:flex;justify-content:space-between;font-size:13px;color:var(--muted)"><span>Flow</span><span id="flowVal">100%</span></div>
          <input class="range" id="flowRange" type="range" min="0" max="100" value="100">
        </div>
      </div>

      <div class="panel">
        <div class="panel-title">üéØ Color</div>
        <div class="color-display" id="colorPreview"></div>
        <div class="color-row">
          <input type="color" id="colorPicker" value="#000000">
          <input type="text" id="hexInput" class="hex-input" maxlength="7" value="#000000">
        </div>
        <div style="margin-top:8px">
          <div style="font-size:13px;color:var(--muted);margin-bottom:6px">Alpha (Color)</div>
          <input class="range" id="colorAlpha" type="range" min="0" max="255" value="255">
        </div>
        <div style="margin-top:10px" class="panel-title">Quick Colors</div>
        <div class="palette">
          <div class="sw" style="background:#000000"></div>
          <div class="sw" style="background:#ffffff"></div>
          <div class="sw" style="background:#FF6B6B"></div>
          <div class="sw" style="background:#FFD93D"></div>
          <div class="sw" style="background:#6BCB77"></div>
          <div class="sw" style="background:#4D96FF"></div>
          <div class="sw" style="background:#D4AF37"></div>
          <div class="sw" style="background:#FF6B9D"></div>
        </div>
      </div>

      <div class="panel">
        <div class="panel-title">üõ† Tools</div>
        <div class="tools">
          <div class="small-row">
            <button class="btn" id="eraserBtn">Eraser</button>
            <button class="btn" id="smudgeBtn">Smudge</button>
            <button class="btn" id="mirrorBtn">Mirror</button>
            <button class="btn" id="radialBtn">Radial</button>
          </div>
          <div class="small-row" style="margin-top:8px">
            <button class="btn" id="undoBtn">‚Ü∂ Undo</button>
            <button class="btn" id="redoBtn">‚Ü∑ Redo</button>
            <button class="btn" id="clearBtn">Clear</button>
            <button class="btn" id="downloadBtn">‚¨á Download</button>
          </div>
          <div style="margin-top:10px;display:flex;gap:8px">
            <button class="btn" id="addLayerBtn">+ Layer</button>
            <button class="btn" id="mergeBtn">Merge All</button>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="panel-title">üìö Layers</div>
        <div class="layers-list" id="layersList"></div>
      </div>
    </div>
  </div>

  <div class="footer">Forever ‚Äî Priyanshu √ó Ria</div>

<script>
/* =========================
   Core drawing engine
   ========================= */
const canvas = document.getElementById('drawingCanvas');
const wrap = document.getElementById('canvasWrap');
const ctx = canvas.getContext('2d', { willReadFrequently: true });

let DPR = Math.max(1, window.devicePixelRatio || 1);

// State
let currentBrush = 'pencil';
let currentColor = '#000000';
let colorAlpha = 1; // 0..1
let brushSize = 10;
let brushOpacity = 1; // 0..1 (from opacityRange)
let brushFlow = 1; // 0..1
let brushHardness = 1;
let isErasing = false;
let isSmudging = false;
let enableMirror = false;
let enableRadial = false;
let isDrawing = false;
let lastPoint = null;
let layers = [];
let currentLayer = 0;
let history = [];
let historyStep = -1;
const MAX_HISTORY = 40;

// Helpers: UI elements
const sizeRange = document.getElementById('sizeRange');
const sizeVal = document.getElementById('sizeVal');
const opacityRange = document.getElementById('opacityRange');
const opVal = document.getElementById('opVal');
const flowRange = document.getElementById('flowRange');
const flowVal = document.getElementById('flowVal');
const colorPicker = document.getElementById('colorPicker');
const hexInput = document.getElementById('hexInput');
const colorPreview = document.getElementById('colorPreview');
const colorAlphaInput = document.getElementById('colorAlpha');
const layersList = document.getElementById('layersList');

function showToast(msg, t=1100){
  const d = document.createElement('div'); d.className='toast'; d.textContent = msg;
  document.body.appendChild(d); setTimeout(()=>d.remove(), t);
}

// --- DPR aware resize
function resizeCanvas() {
  DPR = Math.max(1, window.devicePixelRatio || 1);
  const rect = wrap.getBoundingClientRect();
  const cssW = Math.max(200, Math.floor(rect.width));
  const cssH = Math.max(200, Math.floor(rect.height));
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  const pxW = Math.floor(cssW * DPR);
  const pxH = Math.floor(cssH * DPR);
  // adjust each layer to new pixel size preserving content
  for (let layer of layers) {
    if (layer.canvas.width === pxW && layer.canvas.height === pxH) continue;
    const tmp = document.createElement('canvas');
    tmp.width = pxW; tmp.height = pxH;
    const tctx = tmp.getContext('2d');
    // draw old content stretched to new size (keeps relative positions)
    tctx.drawImage(layer.canvas, 0, 0, layer.canvas.width, layer.canvas.height, 0,0, pxW, pxH);
    layer.canvas.width = pxW; layer.canvas.height = pxH;
    layer.ctx = layer.canvas.getContext('2d', { willReadFrequently: true });
    layer.ctx.setTransform(DPR,0,0,DPR,0,0); // scale so drawing uses CSS pixels
    layer.ctx.clearRect(0,0,layer.canvas.width, layer.canvas.height);
    layer.ctx.drawImage(tmp, 0,0, pxW, pxH, 0,0, pxW, pxH);
  }
  canvas.width = pxW; canvas.height = pxH;
  ctx.setTransform(DPR,0,0,DPR,0,0);
  redrawAll();
}

// Create layer (pixel canvas) and set transform so drawing uses CSS pixels
function createLayer(name='Layer') {
  const cssW = Math.floor(canvas.clientWidth || wrap.clientWidth);
  const cssH = Math.floor(canvas.clientHeight || wrap.clientHeight);
  const c = document.createElement('canvas');
  c.width = Math.max(1, cssW * DPR);
  c.height = Math.max(1, cssH * DPR);
  const cctx = c.getContext('2d', { willReadFrequently: true });
  cctx.setTransform(DPR,0,0,DPR,0,0); // now draw coordinates use CSS pixels
  cctx.clearRect(0,0,c.width,c.height);
  return {
    canvas: c,
    ctx: cctx,
    name,
    visible:true,
    opacity:1,
    blend:'source-over'
  };
}

function init() {
  // ensure at least one layer
  layers = [ createLayer('Layer 1') ];
  currentLayer = 0;
  resizeCanvas();
  saveHistory(); // initial blank
  renderLayersPanel();
}
window.addEventListener('resize', ()=>{ clearTimeout(window.__resizeTimer); window.__resizeTimer=setTimeout(resizeCanvas,80); });

// Convert hex + alpha to rgba
function hexToRgba(hex, a=1){
  if (!hex) return `rgba(0,0,0,${a})`;
  const h = hex.replace('#','');
  const full = h.length===3 ? h.split('').map(c=>c+c).join('') : h;
  const num = parseInt(full,16);
  const r=(num>>16)&255, g=(num>>8)&255, b=num&255;
  return `rgba(${r},${g},${b},${a})`;
}

// Redraw combined layers to main canvas
function redrawAll(){
  // fill white background
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.restore();
  for (let layer of layers){
    if (!layer.visible) continue;
    ctx.globalAlpha = layer.opacity;
    ctx.globalCompositeOperation = layer.blend || 'source-over';
    // layer.canvas is pixel-sized; draw scaled-down by DPR automatically because ctx has transform
    ctx.drawImage(layer.canvas, 0,0, layer.canvas.width / DPR, layer.canvas.height / DPR);
  }
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = 'source-over';
}

// Save snapshot for undo/redo
function saveHistory(){
  try {
    // store data URLs (may be memory heavy; cap to MAX_HISTORY)
    const snap = layers.map(l => l.canvas.toDataURL('image/png'));
    // if we undid and then draw, drop future states
    if (historyStep < history.length - 1) history = history.slice(0, historyStep+1);
    history.push(snap);
    if (history.length > MAX_HISTORY) history.shift();
    historyStep = history.length - 1;
  } catch(e){ console.warn('history save failed', e); }
}

function undo(){
  if (historyStep > 0) {
    historyStep--;
    applyHistorySnapshot(history[historyStep]);
  } else showToast('No more undo');
}
function redo(){
  if (historyStep < history.length - 1) {
    historyStep++;
    applyHistorySnapshot(history[historyStep]);
  } else showToast('No more redo');
}
function applyHistorySnapshot(snap){
  if (!snap) return;
  let loaded = 0;
  for (let i = 0; i < snap.length; i++){
    const data = snap[i];
    const img = new Image();
    img.onload = (() => {
      return function(){
        const l = layers[i];
        // resize layer canvas if needed
        l.ctx.clearRect(0,0,l.canvas.width / DPR, l.canvas.height / DPR);
        // draw image scaled to layer pixel size
        l.ctx.drawImage(img, 0,0, l.canvas.width / DPR, l.canvas.height / DPR);
        loaded++;
        if (loaded === snap.length) redrawAll();
      }
    })();
    img.src = data;
  }
}

// Brush texture / style
function getBrushProfile(brush){
  switch(brush){
    case 'pencil': return {alpha:0.9, blur:0, jitter:0};
    case 'charcoal': return {alpha:0.55, blur:0.6, jitter:0.2};
    case 'marker': return {alpha:0.92, blur:0.2, jitter:0};
    case 'oil': return {alpha:0.7, blur:1.0, jitter:0.15};
    case 'watercolor': return {alpha:0.35, blur:2.0, jitter:0.35};
    case 'airbrush': return {alpha:0.22, blur:3.0, jitter:0};
    default: return {alpha:0.9, blur:0, jitter:0};
  }
}

// Small smudge implementation: copy a blurred patch and draw over stroke
function smudgeStroke(layerCtx, from, to, size){
  // capture a rectangle around from point, blur and draw slightly towards to point
  const sx = Math.floor(Math.min(from.x, to.x) - size);
  const sy = Math.floor(Math.min(from.y, to.y) - size);
  const sw = Math.ceil(Math.abs(to.x - from.x) + size*2);
  const sh = Math.ceil(Math.abs(to.y - from.y) + size*2);
  if (sw <=0 || sh <=0) return;
  try {
    const tmp = document.createElement('canvas');
    tmp.width = sw; tmp.height = sh;
    const tctx = tmp.getContext('2d');
    // draw portion from layerCtx (layerCtx uses CSS coordinates because transform set)
    tctx.drawImage(layerCtx.canvas, sx, sy, sw, sh, 0,0, sw, sh);
    // apply blur via canvas filter
    tctx.filter = `blur(${Math.max(1, size*0.08)}px)`;
    const blurred = document.createElement('canvas');
    blurred.width = sw; blurred.height = sh;
    const bctx = blurred.getContext('2d');
    bctx.drawImage(tmp,0,0);
    // draw blurred at slightly shifted position (towards 'to')
    const dx = (to.x - from.x) * 0.2;
    const dy = (to.y - from.y) * 0.2;
    layerCtx.globalAlpha = 0.9;
    layerCtx.drawImage(blurred, sx+dx, sy+dy, sw, sh);
    layerCtx.globalAlpha = 1;
  } catch(e){ /* ignore heavy operations errors on low memory devices */ }
}

// draw a segment onto current layer (coordinates are CSS pixels)
function drawSegment(from, to, pressure){
  const layer = layers[currentLayer];
  const lctx = layer.ctx;
  const profile = getBrushProfile(currentBrush);
  const p = pressure !== undefined ? pressure : 0.5;
  const size = Math.max(1, brushSize * (1 + (p-0.5)));
  lctx.save();
  lctx.lineCap = 'round';
  lctx.lineJoin = 'round';
  lctx.lineWidth = size;
  lctx.globalAlpha = (isErasing ? 1 : profile.alpha * brushOpacity * brushFlow);
  lctx.filter = isSmudging ? `blur(${Math.min(6, size*0.08)}px)` : 'none';
  if (isErasing) {
    lctx.globalCompositeOperation = 'destination-out';
    lctx.strokeStyle = `rgba(0,0,0,1)`;
  } else {
    lctx.globalCompositeOperation = 'source-over';
    lctx.strokeStyle = hexToRgba(currentColor, colorAlpha * brushOpacity * brushFlow);
  }
  lctx.beginPath();
  lctx.moveTo(from.x, from.y);
  lctx.lineTo(to.x, to.y);
  lctx.stroke();
  lctx.restore();

  if (isSmudging) {
    // simple smudge effect
    try { smudgeStroke(lctx, from, to, size); } catch(e){ }
  }

  // mirror / radial duplicates (draw directly to layer ctx)
  if (enableMirror || enableRadial) {
    if (enableMirror) {
      const w = canvas.clientWidth;
      const mx1 = w - from.x;
      const mx2 = w - to.x;
      lctx.save();
      lctx.globalAlpha = (isErasing ? 1 : profile.alpha * brushOpacity * brushFlow);
      if (isErasing) { lctx.globalCompositeOperation='destination-out'; lctx.strokeStyle='rgba(0,0,0,1)'; }
      else { lctx.strokeStyle = hexToRgba(currentColor, colorAlpha * brushOpacity * brushFlow); }
      lctx.beginPath();
      lctx.moveTo(mx1, from.y);
      lctx.lineTo(mx2, to.y);
      lctx.lineWidth = size;
      lctx.lineCap='round';
      lctx.stroke();
      lctx.restore();
    }
    if (enableRadial) {
      const cx = canvas.clientWidth/2;
      const cy = canvas.clientHeight/2;
      const seg = 6;
      const angle = Math.atan2(to.y - cy, to.x - cx);
      const dist = Math.hypot(to.x - cx, to.y - cy);
      for (let i=1;i<seg;i++){
        const a = angle + i * Math.PI*2/seg;
        const ax = cx + Math.cos(a) * dist;
        const ay = cy + Math.sin(a) * dist;
        const la = Math.atan2(from.y - cy, from.x - cx);
        const ldist = Math.hypot(from.x - cx, from.y - cy);
        const aFromX = cx + Math.cos(la + i*Math.PI*2/seg) * ldist;
        const aFromY = cy + Math.sin(la + i*Math.PI*2/seg) * ldist;
        lctx.save();
        lctx.globalAlpha = (isErasing ? 1 : profile.alpha * brushOpacity * brushFlow);
        if (isErasing) { lctx.globalCompositeOperation='destination-out'; lctx.strokeStyle='rgba(0,0,0,1)'; }
        else { lctx.strokeStyle = hexToRgba(currentColor, colorAlpha * brushOpacity * brushFlow); }
        lctx.beginPath();
        lctx.moveTo(aFromX, aFromY);
        lctx.lineTo(ax, ay);
        lctx.lineWidth = size;
        lctx.lineCap='round';
        lctx.stroke();
        lctx.restore();
      }
    }
  }

  // occasional sparkle
  if (!isErasing && Math.random() < 0.05) createSparkle(to.x, to.y, currentColor);
}

// sparkle effect: position in CSS pixels -> place absolute element
function createSparkle(x, y, color){
  const rect = canvas.getBoundingClientRect();
  const el = document.createElement('div');
  el.className='sparkle';
  el.style.left = (rect.left + x - 3) + 'px';
  el.style.top = (rect.top + y - 3) + 'px';
  el.style.background = color;
  el.style.boxShadow = `0 0 8px ${color}`;
  document.body.appendChild(el);
  setTimeout(()=>el.remove(), 700);
}

/* =========================
   Pointer events (touch + stylus)
   ========================= */
function getCanvasCoords(e){
  const rect = canvas.getBoundingClientRect();
  // pointer events: e.clientX/Y
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);
  return { x, y };
}

canvas.addEventListener('pointerdown', (e) => {
  if (e.button && e.button !== 0) return; // only left
  canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId);
  isDrawing = true;
  lastPoint = getCanvasCoords(e);
  // read pressure if available (0..1), fallback to 0.5
  const pressure = (typeof e.pressure === 'number' && e.pressure > 0) ? e.pressure : (e.pointerType === 'pen' ? 0.7 : 0.6);
  // begin path -> we store lastPoint and start drawing on move
  // Save history at start of stroke
  saveHistory();
  e.preventDefault();
});

canvas.addEventListener('pointermove', (e) => {
  if (!isDrawing) return;
  const p = getCanvasCoords(e);
  const pressure = (typeof e.pressure === 'number') ? Math.max(0.01, e.pressure) : 0.6;
  if (lastPoint) {
    drawSegment(lastPoint, p, pressure);
    lastPoint = p;
    // render to main canvas for user feedback
    redrawAll();
    // draw active layer only on top can be optimized but this is simpler
  } else lastPoint = p;
  e.preventDefault();
});

canvas.addEventListener('pointerup', (e) => {
  isDrawing = false;
  canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
  lastPoint = null;
  // commit snapshot after stroke
  saveHistory();
  e.preventDefault();
});

canvas.addEventListener('pointercancel', ()=>{ isDrawing=false; lastPoint=null; });

/* =========================
   UI bindings
   ========================= */
// Brush buttons
document.querySelectorAll('.brush-btn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('.brush-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    currentBrush = btn.dataset.brush;
    isErasing = false;
    document.getElementById('eraserBtn').style.background='';
  });
});

// sliders
sizeRange.addEventListener('input', ()=>{ brushSize = Number(sizeRange.value); sizeVal.textContent = brushSize; });
opacityRange.addEventListener('input', ()=>{ brushOpacity = Number(opacityRange.value)/100; opVal.textContent = opacityRange.value + '%'; });
flowRange.addEventListener('input', ()=>{ brushFlow = Number(flowRange.value)/100; flowVal.textContent = flowRange.value + '%'; });

// color UI
function updateColorUI(){ colorPreview.style.background = currentColor; colorPreview.style.opacity = colorAlpha; colorPicker.value = currentColor; hexInput.value = currentColor; }
colorPicker.addEventListener('input', ()=>{ currentColor = colorPicker.value; updateColorUI(); });
hexInput.addEventListener('change', ()=>{ const v = hexInput.value.trim(); if(/^#([0-9A-Fa-f]{6})$/.test(v)){ currentColor=v; updateColorUI(); }});
colorAlphaInput.addEventListener('input', ()=>{ colorAlpha = Number(colorAlphaInput.value)/255; updateColorUI(); });
document.querySelectorAll('.sw').forEach(s=> s.addEventListener('click', (ev)=>{ const bg = getComputedStyle(s).backgroundColor; currentColor = rgbToHex(bg); updateColorUI(); }));

function rgbToHex(rgb){
  const m = rgb.match(/\d+/g);
  if(!m) return '#000000';
  const r = parseInt(m[0]).toString(16).padStart(2,'0');
  const g = parseInt(m[1]).toString(16).padStart(2,'0');
  const b = parseInt(m[2]).toString(16).padStart(2,'0');
  return `#${r}${g}${b}`;
}

// Tools
document.getElementById('eraserBtn').addEventListener('click', ()=>{
  isErasing = !isErasing; isSmudging = false;
  document.getElementById('eraserBtn').style.background = isErasing ? 'rgba(212,175,55,0.3)' : '';
  document.getElementById('smudgeBtn').style.background = '';
});
document.getElementById('smudgeBtn').addEventListener('click', ()=>{
  isSmudging = !isSmudging; isErasing = false;
  document.getElementById('smudgeBtn').style.background = isSmudging ? 'rgba(212,175,55,0.3)' : '';
  document.getElementById('eraserBtn').style.background = '';
});
document.getElementById('mirrorBtn').addEventListener('click', ()=>{ enableMirror = !enableMirror; document.getElementById('mirrorBtn').style.background = enableMirror ? 'rgba(212,175,55,0.3)' : ''; });
document.getElementById('radialBtn').addEventListener('click', ()=>{ enableRadial = !enableRadial; document.getElementById('radialBtn').style.background = enableRadial ? 'rgba(212,175,55,0.3)' : ''; });

document.getElementById('undoBtn').addEventListener('click', undo);
document.getElementById('redoBtn').addEventListener('click', redo);

document.getElementById('clearBtn').addEventListener('click', ()=>{
  if (!confirm('Clear canvas? This cannot be undone.')) return;
  for (let l of layers) l.ctx.clearRect(0,0, canvas.clientWidth, canvas.clientHeight);
  redrawAll();
  saveHistory();
});

document.getElementById('downloadBtn').addEventListener('click', ()=>{
  // merge all layers at pixel resolution
  const out = document.createElement('canvas');
  out.width = canvas.width; out.height = canvas.height;
  const octx = out.getContext('2d');
  octx.fillStyle = '#ffffff'; octx.fillRect(0,0,out.width,out.height);
  for (let l of layers){
    if(!l.visible) continue;
    octx.globalAlpha = l.opacity;
    octx.globalCompositeOperation = l.blend || 'source-over';
    octx.drawImage(l.canvas, 0,0);
  }
  const link = document.createElement('a');
  link.href = out.toDataURL('image/png');
  link.download = 'priyanshu-ria-drawing.png';
  link.click();
});

document.getElementById('addLayerBtn').addEventListener('click', ()=>{
  const name = `Layer ${layers.length+1}`;
  const l = createLayer(name);
  layers.push(l);
  currentLayer = layers.length - 1;
  renderLayersPanel();
  redrawAll();
  saveHistory();
});

document.getElementById('mergeBtn').addEventListener('click', ()=>{
  if (layers.length <= 1) { showToast('Nothing to merge'); return; }
  // merge top into bottom
  const base = layers[0];
  const tmp = document.createElement('canvas'); tmp.width = base.canvas.width; tmp.height = base.canvas.height;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(base.canvas,0,0);
  for (let i=1;i<layers.length;i++){
    const l = layers[i];
    tctx.globalAlpha = l.opacity;
    tctx.drawImage(l.canvas,0,0);
  }
  // replace base with merged, keep only base
  base.ctx.clearRect(0,0, base.canvas.width / DPR, base.canvas.height / DPR);
  base.ctx.drawImage(tmp,0,0);
  layers = [ base ];
  currentLayer = 0;
  renderLayersPanel();
  redrawAll();
  saveHistory();
});

/* =========================
   Layer UI rendering and controls
   ========================= */
function renderLayersPanel(){
  layersList.innerHTML = '';
  for (let i = layers.length - 1; i >= 0; i--){ // show top layer first
    const l = layers[i];
    const item = document.createElement('div'); item.className = 'layer-item';
    if (i === currentLayer) item.classList.add('active');
    const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center'; left.style.gap='8px';
    const name = document.createElement('div'); name.textContent = l.name; name.style.fontSize='13px';
    const visBtn = document.createElement('button'); visBtn.className='btn'; visBtn.style.padding='6px'; visBtn.textContent = l.visible ? 'üëÅ' : 'üö´';
    visBtn.addEventListener('click', (e)=>{ e.stopPropagation(); l.visible = !l.visible; renderLayersPanel(); redrawAll(); });
    left.appendChild(visBtn); left.appendChild(name);

    const right = document.createElement('div'); right.className='layer-controls';
    const up = document.createElement('button'); up.className='btn'; up.textContent='‚Üë';
    const down = document.createElement('button'); down.className='btn'; down.textContent='‚Üì';
    const del = document.createElement('button'); del.className='btn'; del.textContent='üóë';
    const opacity = document.createElement('input'); opacity.type='range'; opacity.min=0; opacity.max=100; opacity.value = Math.round(l.opacity*100);
    opacity.style.width='80px';
    opacity.addEventListener('input', (ev)=>{ l.opacity = ev.target.value/100; redrawAll(); });

    up.addEventListener('click', (e)=>{
      e.stopPropagation();
      const idx = layers.indexOf(l);
      if (idx < layers.length - 1) { layers.splice(idx,1); layers.splice(idx+1,0,l); currentLayer = layers.indexOf(l); renderLayersPanel(); redrawAll(); saveHistory(); }
    });
    down.addEventListener('click', (e)=>{
      e.stopPropagation();
      const idx = layers.indexOf(l);
      if (idx > 0) { layers.splice(idx,1); layers.splice(idx-1,0,l); currentLayer = layers.indexOf(l); renderLayersPanel(); redrawAll(); saveHistory(); }
    });
    del.addEventListener('click', (e)=>{
      e.stopPropagation();
      if (!confirm('Delete this layer?')) return;
      const idx = layers.indexOf(l);
      layers.splice(idx,1);
      currentLayer = Math.max(0, idx-1);
      renderLayersPanel();
      redrawAll();
      saveHistory();
    });

    right.appendChild(opacity); right.appendChild(up); right.appendChild(down); right.appendChild(del);

    item.appendChild(left); item.appendChild(right);
    item.addEventListener('click', ()=>{ currentLayer = layers.indexOf(l); renderLayersPanel(); });

    layersList.appendChild(item);
  }
}

/* =========================
   Startup
   ========================= */
init();
renderLayersPanel();
updateColorUI();

/* =========================
   Small helpers
   ========================= */
function showToast(msg){ const t = document.createElement('div'); t.className='toast'; t.textContent=msg; document.body.appendChild(t); setTimeout(()=>t.remove(),1200); }
function hexToRgba(hex,a=1){ if(!hex) return `rgba(0,0,0,${a})`; const h=hex.replace('#',''); const fh=h.length===3? h.split('').map(c=>c+c).join(''):h; const n=parseInt(fh,16); const r=(n>>16)&255,g=(n>>8)&255,b=n&255; return `rgba(${r},${g},${b},${a})`; }
</script>
</body>
</html>
